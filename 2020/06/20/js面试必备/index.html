<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 5.4.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>Javascript前端面试常见知识点 - Captain</title>

  

  
    <meta name="description" content="Javascript前端面试常考知识点(1)">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript前端面试常见知识点">
<meta property="og:url" content="https://blog.kenym.cn/2020/06/20/js%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/index.html">
<meta property="og:site_name" content="Captain">
<meta property="og:description" content="Javascript前端面试常考知识点(1)">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-20T05:15:43.000Z">
<meta property="article:modified_time" content="2022-05-05T15:30:43.389Z">
<meta property="article:author" content="Jinxb">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/jinxb/jinxb.github.io/images/hp.jpeg">
  

  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.2/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://cdn.jsdelivr.net/gh/jinxb/jinxb.github.io/images/hp.jpeg" onerror="javascript:this.classList.add('error');this.src='https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/image/2659360.svg';"></a><a class="title" href="/"><div class="main">Captain</div><div class="sub normal cap">生活就是苦中作乐</div><div class="sub hover cap" style="opacity:0">与善者为伍,与智者同行。</div></a></div>
<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/wiki/">项目</a><a class="nav-item" href="/record/">笔记</a><a class="nav-item" href="/about/">更多</a></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">一、变量类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85"><span class="toc-text">二、作用域和闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%BC%82%E6%AD%A5"><span class="toc-text">三、异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text">四、原型链与继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81DOM%E6%93%8D%E4%BD%9C%E4%B8%8EBOM%E6%93%8D%E4%BD%9C"><span class="toc-text">五、DOM操作与BOM操作</span></a></li></ol></div></div></div>


</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/jinxb" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.3/social/08a41b181ce68.svg"/></a><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.3/social/3845874.svg"/></a><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.3/social/3616429.svg"/></a><a class="social" href="/about/#comments" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.3/social/942ebbf1a4b91.svg"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      

<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/">JavaScript</a></div><div id="post-meta">发布于&nbsp;<time datetime="2020-06-20T05:15:43.000Z">2020-06-20</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>Javascript前端面试常见知识点</span></h1>
<blockquote>
<p>Javascript前端面试常考知识点(1)</p>
</blockquote>
<span id="more"></span> 

<h2 id="一、变量类型"><a href="#一、变量类型" class="headerlink" title="一、变量类型"></a>一、变量类型</h2><h1 id="1-JS-的数据类型分类"><a href="#1-JS-的数据类型分类" class="headerlink" title="1.JS 的数据类型分类"></a>1.JS 的数据类型分类</h1><p>根据 JavaScript 中的变量类型传递方式，分为基本数据类型和引用数据类型。其中基本数据类型包括Undefined、Null、Boolean、Number、String、Symbol (ES6新增，表示独一无二的值)，而引用数据类型统称为Object对象，主要包括对象、数组和函数。在参数传递方式上，基本类型是按值传递，引用类型是按共享传递。</p>
<p>题目：基本类型和引用类型的区别</p>
<p>基本类型和引用类型存储于内存的位置不同，基本类型直接存储在栈中,而引用类型的对象存储在堆中，与此同时，在栈中存储了指针，而这个指针指向正是堆中实体的起始位置。下面通过一个小题目，来看下两者的主要区别：</p>
<p>&#x2F;&#x2F; 基本类型</p>
<blockquote>
<pre><code>var a = 10
var b = a
b = 20
console.log(a)  // 10
console.log(b)  // 20
</code></pre>
</blockquote>
<p>上述代码中，a b都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子：</p>
<p>&#x2F;&#x2F; 引用类型</p>
<blockquote>
<pre><code>var a = &#123;x: 10, y: 20&#125;
var b = a
b.x = 100
b.y = 200
console.log(a)  // &#123;x: 100, y: 200&#125;
console.log(b)  // &#123;x: 100, y: 200&#125;
</code></pre>
</blockquote>
<p>上述代码中，a b都是引用类型。在执行了b &#x3D; a之后，修改b的属性值，a的也跟着变化。因为a和b都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此b修改属性时，a的值随之改动</p>
<h1 id="2-数据类型的判断"><a href="#2-数据类型的判断" class="headerlink" title="2.数据类型的判断"></a>2.数据类型的判断</h1><p>1）typeof<br>typeof返回一个表示数据类型的字符串，返回结果包括：number、boolean、string、symbol、object、undefined、function等7种数据类型，但不能判断null、array等</p>
<blockquote>
<pre><code>typeof Symbol(); // symbol 有效
typeof &#39;&#39;; // string 有效
typeof 1; // number 有效
typeof true; //boolean 有效
typeof undefined; //undefined 有效
typeof new Function(); // function 有效
typeof null; //object 无效
typeof [] ; //object 无效
typeof new Date(); //object 无效
typeof new RegExp(); //object 无效
</code></pre>
</blockquote>
<p>2）instanceof<br>instanceof 是用来判断A是否为B的实例，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，但它不能检测null 和 undefined</p>
<blockquote>
<pre><code>[] instanceof Array; //true
&#123;&#125; instanceof Object;//true
new Date() instanceof Date;//true
new RegExp() instanceof RegExp//true
null instanceof Null//报错
undefined instanceof undefined//报错
</code></pre>
</blockquote>
<p>3）严格运算符&#x3D;&#x3D;&#x3D;<br>只能用于判断null和undefined，因为这两种类型的值都是唯一的。</p>
<p>4）constructor<br>constructor作用和instanceof非常相似。但constructor检测 Object与instanceof不一样，还可以处理基本数据类型的检测。<br>不过函数的 constructor 是不稳定的，这个主要体现在把类的原型进行重写，在重写的过程中很有可能出现把之前的constructor给覆盖了，这样检测出来的结果就是不准确的。</p>
<p>5）Object.prototype.toString.call()</p>
<blockquote>
<pre><code>Object.prototype.toString.call() 是最准确最常用的方式。

Object.prototype.toString.call(&#39;&#39;) ;   // [object String]
Object.prototype.toString.call(1) ;    // [object Number]
Object.prototype.toString.call(true) ; // [object Boolean]
Object.prototype.toString.call(undefined) ; // [object Undefined]
Object.prototype.toString.call(null) ; // [object Null]
Object.prototype.toString.call(new Function()) ; // [object Function]
Object.prototype.toString.call(new Date()) ; // [object Date]
Object.prototype.toString.call([]) ; // [object Array]
Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
Object.prototype.toString.call(new Error()) ; // [object Error]
</code></pre>
</blockquote>
<h1 id="3-浅拷贝与深拷贝"><a href="#3-浅拷贝与深拷贝" class="headerlink" title="3.浅拷贝与深拷贝"></a>3.浅拷贝与深拷贝</h1><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p>
<p>浅拷贝的实现方式（详见浅拷贝与深拷贝）：</p>
<pre><code>Object.assign()：需注意的是目标对象只有一层的时候，是深拷贝
Array.prototype.concat()
Array.prototype.slice()
</code></pre>
<p>深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。</p>
<p>深拷贝的实现方式：</p>
<p>热门的函数库lodash，也有提供_.cloneDeep用来做深拷贝<br>jquery 提供一个$.extend可以用来做深拷贝<br>JSON.parse(JSON.stringify())<br>手写递归方法<br>递归实现深拷贝的原理：要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复。</p>
<blockquote>
<pre><code>//定义检测数据类型的功能函数
function checkedType(target) &#123;
  return Object.prototype.toString.call(target).slice(8, -1)
&#125;
//实现深度克隆---对象/数组
function clone(target) &#123;
  //判断拷贝的数据类型
  //初始化变量result 成为最终克隆的数据
  let result,
    targetType = checkedType(target)
  if (targetType === &#39;Object&#39;) &#123;
    result = &#123;&#125;
  &#125; else if (targetType === &#39;Array&#39;) &#123;
    result = []
  &#125; else &#123;
    return target
  &#125;
  //遍历目标数据
  for (let i in target) &#123;
    //获取遍历数据结构的每一项值。
    let value = target[i]
    //判断目标结构里的每一值是否存在对象/数组
    if (checkedType(value) === &#39;Object&#39; || checkedType(value) === &#39;Array&#39;) &#123;
      //对象/数组里嵌套了对象/数组
      //继续遍历获取到value值
      result[i] = clone(value)
    &#125; else &#123;
      //获取到value值是基本的数据类型或者是函数。
      result[i] = value
    &#125;
  &#125;
  return result
&#125;
</code></pre>
</blockquote>
<h2 id="二、作用域和闭包"><a href="#二、作用域和闭包" class="headerlink" title="二、作用域和闭包"></a>二、作用域和闭包</h2><h1 id="1-执行上下文和执行栈"><a href="#1-执行上下文和执行栈" class="headerlink" title="1.执行上下文和执行栈"></a>1.执行上下文和执行栈</h1><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。<br>执行上下文的生命周期包括三个阶段：创建阶段执行阶段回收阶段，我们重点介绍创建阶段。</p>
<p>创建阶段（当函数被调用，但未执行任何其内部代码之前）会做以下三件事：</p>
<p>创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。<br>创建作用域链：下文会介绍<br>确定this指向：下文会介绍</p>
<blockquote>
<pre><code>function test(arg)&#123;
// 1. 形参 arg 是 &quot;hi&quot;
// 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 function
console.log(arg);  
var arg = &#39;hello&#39;; // 3.var arg 变量声明被忽略， arg = &#39;hello&#39;被执行
function arg()&#123;
console.log(&#39;hello world&#39;) 
&#125;
console.log(arg);  
&#125;
test(&#39;hi&#39;);
/* 输出：
function arg() &#123;
console.log(&#39;hello world&#39;);
&#125;
hello 
*/
</code></pre>
</blockquote>
<p>这是因为当函数执行的时候,首先会形成一个新的私有的作用域，然后依次按照如下的步骤执行：</p>
<p>如果有形参，先给形参赋值<br>进行私有作用域中的预解释，函数声明优先级比变量声明高，最后后者会被前者所覆盖，但是可以重新赋值<br>私有作用域中的代码从上到下执行<br>函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文，那如何管理创建的那么多执行上下文呢？</p>
<p>JavaScript 引擎创建了执行栈来管理执行上下文。可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。</p>
<p>从上面的流程图，我们需要记住几个关键点：</p>
<p>JavaScript执行在单线程上，所有的代码都是排队执行。<br>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。<br>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。<br>浏览器的JS执行引擎总是访问栈顶的执行上下文。<br>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</p>
<h1 id="2-作用域与作用域链"><a href="#2-作用域与作用域链" class="headerlink" title="2.作用域与作用域链"></a>2.作用域与作用域链</h1><p>ES6 到来JavaScript 有全局作用域、函数作用域和块级作用域（ES6新增）。我们可以这样理解：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。<br>在介绍作用域链之前，先要了解下自由变量，如下代码中，console.log(a)要得到a变量，但是在当前的作用域中没有定义a（可对比一下b）。当前作用域没有定义的变量，这成为 自由变量。</p>
<blockquote>
<pre><code>var a = 100
function fn() &#123;
var b = 200
console.log(a) // 这里的a在这里就是一个自由变量
console.log(b)
&#125;
fn()
</code></pre>
</blockquote>
<p>自由变量的值如何得到 —— 向父级作用域(创建该函数的那个父级作用域)寻找。如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链 。</p>
<blockquote>
<pre><code>function F1() &#123;
var a = 100
return function () &#123;
    console.log(a)
&#125;
&#125;
function F2(f1) &#123;
var a = 200
console.log(f1())
&#125;
var f1 = F1()
F2(f1) // 100
</code></pre>
</blockquote>
<p>上述代码中，自由变量a的值，从函数F1中查找而不是F2,这是因为当自由变量从作用域链中去寻找，依据的是函数定义时的作用域链，而不是函数执行时。</p>
<h1 id="3-闭包是什么"><a href="#3-闭包是什么" class="headerlink" title="3.闭包是什么"></a>3.闭包是什么</h1><p>闭包这个概念也是JavaScript中比较抽象的概念，我个人理解，闭包是就是函数中的函数(其他语言不能这样),里面的函数可以访问外面函数的变量，外面的变量的是这个内部函数的一部分。</p>
<p>闭包的作用：</p>
<p>使用闭包可以访问函数中的变量。<br>可以使变量长期保存在内存中，生命周期比较长。<br>闭包不能滥用，否则会导致内存泄露，影响网页的性能。闭包使用完了后，要立即释放资源，将引用变量指向null。</p>
<p>闭包主要有两个应用场景：</p>
<p>函数作为参数传递（见作用域部分例子）<br>函数作为返回值（如下例）</p>
<blockquote>
<pre><code>function outer() &#123;
var num = 0 //内部变量
return function add() &#123;
//通过return返回add函数，就可以在outer函数外访问了。
num++ //内部函数有引用，作为add函数的一部分了
console.log(num)
&#125;
&#125;
var func1 = outer() //
func1() //实际上是调用add函数， 输出1
func1() //输出2
var func2 = outer()
func2() // 输出1
func2() // 输出2
</code></pre>
</blockquote>
<h1 id="4-this全面解析"><a href="#4-this全面解析" class="headerlink" title="4.this全面解析"></a>4.this全面解析</h1><p>先搞明白一个很重要的概念 —— this的值是在执行的时候才能确认，定义的时候不能确认！ 为什么呢 —— 因为this是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子：</p>
<blockquote>
<pre><code>// 情况1
function foo() &#123;
  console.log(this.a) //1
&#125;
var a = 1
foo()

// 情况2
function fn()&#123;
  console.log(this);
&#125;
var obj=&#123;fn:fn&#125;;
obj.fn(); //this-&gt;obj

// 情况3
function CreateJsPerson(name,age)&#123;
//this是当前类的一个实例p1
this.name=name; //=&gt;p1.name=name
this.age=age; //=&gt;p1.age=age
&#125;
var p1=new CreateJsPerson(&quot;尹华芝&quot;,48);

// 情况4
function add(c, d)&#123;
  return this.a + this.b + c + d;
&#125;
var o = &#123;a:1, b:3&#125;;
add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16
add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34

// 情况5
&lt;button id=&quot;btn1&quot;&gt;箭头函数this&lt;/button&gt;
&lt;script type=&quot;text/javascript&quot;&gt;   
    let btn1 = document.getElementById(&#39;btn1&#39;);
    let obj = &#123;
        name: &#39;kobe&#39;,
        age: 39,
        getName: function () &#123;
            btn1.onclick = () =&gt; &#123;
                console.log(this);//obj
            &#125;;
        &#125;
    &#125;;
    obj.getName();
&lt;/script&gt;
</code></pre>
</blockquote>
<p>接下来我们逐一解释上面几种情况</p>
<p>对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window<br>对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象<br>在构造函数模式中，类中(函数体中)出现的this.xxx&#x3D;xxx中的this是当前类的一个实例<br>call、apply和bind：this 是第一个参数<br>箭头函数this指向:箭头函数没有自己的this，看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。</p>
<h2 id="三、异步"><a href="#三、异步" class="headerlink" title="三、异步"></a>三、异步</h2><h1 id="1-同步-vs-异步"><a href="#1-同步-vs-异步" class="headerlink" title="1.同步 vs 异步"></a>1.同步 vs 异步</h1><p>同步，我的理解是一种线性执行的方式，执行的流程不能跨越。比如说话后在吃饭，吃完饭后在看手机，必须等待上一件事完了，才执行后面的事情。</p>
<p>异步，是一种并行处理的方式，不必等待一个程序执行完，可以执行其它的任务。比方说一个人边吃饭，边看手机，边说话，就是异步处理的方式。在程序中异步处理的结果通常使用回调函数来处理结果。</p>
<blockquote>
<pre><code>// 同步
console.log(100)
alert(200);
console.log(300)  //100 200 300
// 异步
console.log(100) 
setTimeout(function()&#123; 
  console.log(200) 
&#125;) 
console.log(300) //100 300 200
</code></pre>
</blockquote>
<h1 id="2-异步和单线程"><a href="#2-异步和单线程" class="headerlink" title="2.异步和单线程"></a>2.异步和单线程</h1><p>JS 需要异步的根本原因是 JS 是单线程运行的，即在同一时间只能做一件事，不能“一心二用”。为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<p>一个 Ajax 请求由于网络比较慢，请求需要 5 秒钟。如果是同步，这 5 秒钟页面就卡死在这里啥也干不了了。异步的话，就好很多了，5 秒等待就等待了，其他事情不耽误做，至于那 5 秒钟等待是网速太慢，不是因为 JS 的原因。</p>
<h1 id="3-前端异步的场景"><a href="#3-前端异步的场景" class="headerlink" title="3.前端异步的场景"></a>3.前端异步的场景</h1><p>前端使用异步的场景</p>
<p>定时任务：setTimeout，setInterval<br>网络请求：ajax请求，动态加载<br>事件绑定</p>
<h1 id="4-Event-Loop"><a href="#4-Event-Loop" class="headerlink" title="4.Event Loop"></a>4.Event Loop</h1><p>一个完整的 Event Loop 过程，可以概括为以下阶段：</p>
<p>一开始执行栈空,我们可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</p>
<p>全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</p>
<p>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。<br>执行渲染操作，更新界面<br>检查是否存在 Web worker 任务，如果有，则对其进行处理<br>上述过程循环往复，直到两个队列都清空<br>接下来我们看道例子来介绍上面流程：</p>
<blockquote>
<pre><code>Promise.resolve().then(()=&gt;&#123;
  console.log(&#39;Promise1&#39;)  
  setTimeout(()=&gt;&#123;
    console.log(&#39;setTimeout2&#39;)
  &#125;,0)
&#125;)
setTimeout(()=&gt;&#123;
  console.log(&#39;setTimeout1&#39;)
  Promise.resolve().then(()=&gt;&#123;
    console.log(&#39;Promise2&#39;)    
  &#125;)
&#125;,0)
最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2
</code></pre>
</blockquote>
<p>一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出Promise1，同时会生成一个宏任务 setTimeout2<br>然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1<br>在执行宏任务setTimeout1时会生成微任务Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2<br>清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</p>
<h2 id="四、原型链与继承"><a href="#四、原型链与继承" class="headerlink" title="四、原型链与继承"></a>四、原型链与继承</h2><h1 id="1-原型和原型链"><a href="#1-原型和原型链" class="headerlink" title="1.原型和原型链"></a>1.原型和原型链</h1><p>原型：在JavaScript中原型是一个prototype对象，用于表示类型之间的关系。</p>
<p>原型链：JavaScript万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</p>
<blockquote>
<pre><code>var Person = function() &#123;
  this.age = 18
  this.name = &#39;匿名&#39;
&#125;
var Student = function() &#123;&#125;
//创建继承关系,父类实例作为子类原型
Student.prototype = new Person()
var s1 = new Student()
console.log(s1)
</code></pre>
</blockquote>
<p>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__（即它的构造函数的prototype）中寻找。如果一直找到最上层都没有找到，那么就宣告失败，返回undefined。最上层是什么 —— Object.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; null</p>
<h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h1><p>介绍几种常见继承方式（如需了解更多，请点击JavaScript常见的六种继承方式）：</p>
<p>原型链+借用构造函数的组合继承</p>
<blockquote>
<pre><code>function Parent(value) &#123;
this.val = value
&#125;
Parent.prototype.getValue = function() &#123;
console.log(this.val)
&#125;
function Child(value) &#123;
Parent.call(this, value)
&#125;
Child.prototype = new Parent()
const child = new Child(1)
child.getValue() // 1
child instanceof Parent // true
</code></pre>
</blockquote>
<p>以上继承的方式核心是在子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后改变子类的原型为 new Parent() 来继承父类的函数。</p>
<p>这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。</p>
<p>寄生组合继承：这种继承方式对上一种组合继承进行了优化</p>
<blockquote>
<pre><code>function Parent(value) &#123;
this.val = value
&#125;
Parent.prototype.getValue = function() &#123;
console.log(this.val)
&#125;
function Child(value) &#123;
Parent.call(this, value)
&#125;
Child.prototype = Object.create(Parent.prototype, &#123;
constructor: &#123;
value: Child,
enumerable: false,
writable: true,
configurable: true
&#125;
&#125;)
const child = new Child(1)
child.getValue() // 1
child instanceof Parent // true
</code></pre>
</blockquote>
<p>以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p>
<p>ES6中class 的继承<br>ES6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法,这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。需要注意的是，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。</p>
<blockquote>
<pre><code>class Parent &#123;
  constructor(value) &#123;
    this.val = value
  &#125;
  getValue() &#123;
    console.log(this.val)
  &#125;
&#125;
class Child extends Parent &#123;
  constructor(value) &#123;
    super(value)
    this.val = value
  &#125;
&#125;
let child = new Child(1)
child.getValue() // 1
child instanceof Parent // true
class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。
</code></pre>
</blockquote>
<h2 id="五、DOM操作与BOM操作"><a href="#五、DOM操作与BOM操作" class="headerlink" title="五、DOM操作与BOM操作"></a>五、DOM操作与BOM操作</h2><h1 id="1-DOM操作"><a href="#1-DOM操作" class="headerlink" title="1.DOM操作"></a>1.DOM操作</h1><p>当网页被加载时，浏览器会创建页面的文档对象模型(DOM),我们可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。接下来我们介绍常见DOM操作：</p>
<blockquote>
<pre><code>新增节点和移动节点
var div1 = document.getElementById(&#39;div1&#39;)
// 添加新节点
var p1 = document.createElement(&#39;p&#39;)
p1.innerHTML = &#39;this is p1&#39;
div1.appendChild(p1) // 添加新创建的元素
// 移动已有节点。注意，这里是“移动”，并不是拷贝
var p2 = document.getElementById(&#39;p2&#39;)
div1.appendChild(p2)
获取父元素
var div1 = document.getElementById(&#39;div1&#39;)
var parent = div1.parentElement
获取子元素
var div1 = document.getElementById(&#39;div1&#39;)
var child = div1.childNodes
删除节点
var div1 = document.getElementById(&#39;div1&#39;)
var child = div1.childNodes
div1.removeChild(child[0])
</code></pre>
</blockquote>
<h1 id="2-DOM事件模型和事件流"><a href="#2-DOM事件模型和事件流" class="headerlink" title="2.DOM事件模型和事件流"></a>2.DOM事件模型和事件流</h1><p>DOM事件模型分为捕获和冒泡。一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</p>
<p>（1）捕获阶段：事件从window对象自上而下向目标节点传播的阶段；</p>
<p>（2）目标阶段：真正的目标节点正在处理事件的阶段；</p>
<p>（3）冒泡阶段：事件从目标节点自下而上向window对象传播的阶段。</p>
<p>DOM事件捕获的具体流程</p>
<p>捕获是从上到下，事件先从window对象，然后再到document（对象），然后是html标签（通过document.documentElement获取html标签），然后是body标签（通过document.body获取body标签），然后按照普通的html结构一层一层往下传，最后到达目标元素。</p>
<p>接下来我们看个事件冒泡的例子：</p>
<blockquote>
<pre><code>// 事件冒泡
&lt;div id=&quot;outer&quot;&gt;
    &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
......
window.onclick = function() &#123;
    console.log(&#39;window&#39;);
&#125;;
document.onclick = function() &#123;
    console.log(&#39;document&#39;);
&#125;;
document.documentElement.onclick = function() &#123;
    console.log(&#39;html&#39;);
&#125;;
document.body.onclick = function() &#123;
    console.log(&#39;body&#39;);
&#125;
outer.onclick = function(ev) &#123;
    console.log(&#39;outer&#39;);
&#125;;
inner.onclick = function(ev) &#123;
    console.log(&#39;inner&#39;);
&#125;;
</code></pre>
</blockquote>
<p>如何阻止冒泡？</p>
<p>通过event.stopPropagation() 方法阻止事件冒泡到父元素，阻止任何父事件处理程序被执行。<br>我们可以在上例中inner元素的click事件上，添加event.stopPropagation()这句话后，就阻止了父事件的执行，最后只打印了’inner’。</p>
<blockquote>
<pre><code> inner.onclick = function(ev) &#123;
    console.log(&#39;inner&#39;)
    ev.stopPropagation()
 &#125;
</code></pre>
</blockquote>
<h1 id="3-事件代理-事件委托"><a href="#3-事件代理-事件委托" class="headerlink" title="3.事件代理(事件委托)"></a>3.事件代理(事件委托)</h1><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理。</p>
<p>我们设定一种场景，如下代码，一个<div>中包含了若干个<a>，而且还能继续增加。那如何快捷方便地为所有<a>绑定事件呢？</p>
<blockquote>
<pre><code>&lt;div id=&quot;div1&quot;&gt;
    &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt;
&lt;/div&gt;
&lt;button&gt;点击增加一个 a 标签&lt;/button&gt;
</code></pre>
</blockquote>
<p>如果给每个<a>标签一一都绑定一个事件，那对于内存消耗是非常大的。借助事件代理，我们只需要给父容器div绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把父容器的click行为触发，然后把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而完成不同的事。</p>
<blockquote>
<pre><code>var div1 = document.getElementById(&#39;div1&#39;)
div1.addEventListener(&#39;click&#39;, function (e) &#123;
    // e.target 可以监听到触发点击事件的元素是哪一个
    var target = e.target
    if (e.nodeName === &#39;A&#39;) &#123;
        // 点击的是 &lt;a&gt; 元素
        alert(target.innerHTML)
    &#125;
&#125;)
</code></pre>
</blockquote>
<p>最后，使用代理的优点如下：</p>
<p>使代码简洁<br>减少浏览器的内存占用</p>
<h1 id="4-BOM-操作"><a href="#4-BOM-操作" class="headerlink" title="4.BOM 操作"></a>4.BOM 操作</h1><p>BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。</p>
<blockquote>
<pre><code>window.screen对象：包含有关用户屏幕的信息
window.location对象：用于获得当前页面的地址(URL)，并把浏览器重定向到新的页面
window.history对象：浏览历史的前进后退等
window.navigator对象：常常用来获取浏览器信息、是否移动端访问等等
获取屏幕的宽度和高度

console.log(screen.width)
console.log(screen.height)
</code></pre>
</blockquote>
<p>获取网址、协议、path、参数、hash 等</p>
<blockquote>
<pre><code>// 例如当前网址是 https://juejin.im/timeline/frontend?a=10&amp;b=10#some
console.log(location.href)  // https://juejin.im/timeline/frontend?a=10&amp;b=10#some
console.log(location.protocol) // https:
console.log(location.pathname) // /timeline/frontend
console.log(location.search) // ?a=10&amp;b=10
console.log(location.hash) // #some
</code></pre>
</blockquote>
<p>另外，还有调用浏览器的前进、后退功能等</p>
<blockquote>
<pre><code>history.back()
history.forward()
</code></pre>
</blockquote>
<p>获取浏览器特性（即俗称的UA）然后识别客户端，例如判断是不是 Chrome 浏览器</p>
<blockquote>
<pre><code>var ua = navigator.userAgent
var isChrome = ua.indexOf(&#39;Chrome&#39;)
console.log(isChrome)
</code></pre>
</blockquote>
<h1 id="5-Ajax与跨域"><a href="#5-Ajax与跨域" class="headerlink" title="5.Ajax与跨域"></a>5.Ajax与跨域</h1><p>Ajax 是一种异步请求数据的一种技术，对于改善用户的体验和程序的性能很有帮助。<br>简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。Ajax的目的是提高用户体验，较少网络数据的传输量。</p>
<p>如何手写 XMLHttpRequest 不借助任何库</p>
<blockquote>
<pre><code>var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () &#123;
    // 这里的函数异步执行
    if (xhr.readyState == 4) &#123;
        if (xhr.status == 200) &#123;
            alert(xhr.responseText)
        &#125;
    &#125;
&#125;
xhr.open(&quot;GET&quot;, &quot;/api&quot;, false)
xhr.send(null)
</code></pre>
</blockquote>
<p>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。</p>
<p>那么是出于什么安全考虑才会引入这种机制呢？ 其实主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。</p>
<p>然后我们来考虑一个问题，请求跨域了，那么请求到底发出去没有？ 请求必然是发出去了，但是浏览器拦截了响应。</p>
<p>常见的几种跨域解决方案（具体如何实现详见九种跨域方式实现原理（完整版））：</p>
<p>JSONP：利用同源策略对<script>标签不受限制,不过只支持GET请求<br>CORS：实现 CORS 通信的关键是后端，服务端设置 Access-Control-Allow-Origin 就可以开启，备受推崇的跨域解决方案，比 JSONP 简单许多<br>Node中间件代理或nginx反向代理：主要是通过同源策略对服务器不加限制</p>
<h1 id="6-存储"><a href="#6-存储" class="headerlink" title="6.存储"></a>6.存储</h1><p>sessionStorage 、localStorage 和 cookie 之间的区别</p>
<p>共同点：都是保存在浏览器端，且都遵循同源策略。<br>不同点：在于生命周期与作用域的不同<br>作用域：localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下</p>
<p>生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</p>
<p>三者区别</p>
<h2 id="六、模块化"><a href="#六、模块化" class="headerlink" title="六、模块化"></a>六、模块化</h2><p>几种常见模块化规范的简介（详情请点击前端模块化详解(完整版)）：</p>
<p>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案<br>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。<br>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重<br>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</p>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section><section id="share"><div class="header"><span>分享文章</span></div><div class="body"><div class="link"><input class="copy-area" readonly="true" id="copy-link" value="https://blog.kenym.cn/2020/06/20/js%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/" /></div><div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/social/b32ef3da1162a.svg"/></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://blog.kenym.cn/2020/06/20/js%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/&title=Javascript前端面试常见知识点 - Captain&summary=
Javascript前端面试常考知识点(1)
"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/social/80c07e4dbb303.svg"/></a><a class="social share-item email" href="mailto:?subject=Javascript前端面试常见知识点 - Captain&amp;body=https://blog.kenym.cn/2020/06/20/js%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/social/a1b00e20f425d.svg"/></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/social/8411ed322ced6.svg"/></a></div><div class="qrcode" id="qrcode-wechat" style="visibility:hidden;height:0"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=https://blog.kenym.cn/2020/06/20/js%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/index.html"/></div></div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><a id="next" href="/2020/02/20/%E8%B7%A8%E5%9F%9F-1/">jsonp解决跨域<span class="note">较早</span></a><div class="line"></div><a id="prev" href="/2021/11/20/Utils%E5%87%BD%E6%95%B0/">封装一个工具函数<span class="note">较新</span></a></section></div>






  <div class='related-wrap md reveal' id="comments">
    <div class='cmt-title cap theme'>
      快来参与讨论吧
    </div>
    <div class='cmt-body beaudar'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="beaudar" repo="jinxb" issue-term="pathname" theme="preferred-color-scheme" input-position="top" comment-order="desc" loading="false" branch="main"></div>

    </div>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客主页</span><a href="/">主页</a></div><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期发布</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs14">Wiki</span><a href="/wiki/">开源项目</a></div><div class="sitemap-group"><span class="fs14">联系</span><a href="/about/">关于我</a><a target="_blank" rel="noopener" href="https://github.com/jinxb">GitHub</a></div></div><div class="text"><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="https://blog.kenym.cn/">@Jinxb</a> 创建，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.7.0" title="v1.7.0">Stellar</a> 作为主题。</p>
Copyright <i class="far fa-copyright"></i> 2019-2022 丨 <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.kenym.cn/blog-resource/img/icp.png" style="margin-bottom:5px;vertical-align: middle;">  <a href="https://beian.miit.gov.cn" target="_blank">  鄂ICP备2022006222号  </a> 丨 <span id="timeDate">6 </span><span id="times"></span></div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.7.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadBeaudar() {
    const els = document.querySelectorAll("#comments #beaudar");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://beaudar.lipk.org/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
      loadBeaudar();
  });
</script>




<!-- inject -->


  </div>
  <!-- Chatra {literal} -->
  <script>
    (function(d, w, c) {
        w.ChatraID = 'JwbPDuoaf3XEPfh8Y';
        var s = d.createElement('script');
        w[c] = w[c] || function() {
            (w[c].q = w[c].q || []).push(arguments);
        };
        s.async = true;
        s.src = 'https://call.chatra.io/chatra.js';
        if (d.head) d.head.appendChild(s);
    })(document, window, 'Chatra');
  </script>
  <!-- /Chatra {/literal} -->
</body>
</html>
